import re

from lab_3.functions import create_message


# 1. Функция, принимающая на вход некий набор параметров (минимум 3 параметра).
# Внутри себя эта функция содержит заранее определённую строку, в которую можно подставлять значения переменных.
# Функция возвращает строку, в которую вставлены значения, такие что
# 1.1. Как минимум, одно значение - это просто строка
# 1.2. Как минимум, одно значение - это результат арифметической операции
# 1.3. Как минимум, одно значение - это результат вызова другой функции

def get_user_salary_string(name: str, profession: str, days_count: int, salary_per_day: float) -> str:
    # подставляем аргументы в возвращаемую шаблонную строку
    return f"{create_message(profession)(name)}, зарплата за месяц: {days_count * salary_per_day}. {'Возможно' if days_count > 25 else 'Невозможно'} повышение."


# 2. Функция, которая формирует строку, состоящую из повторений комбинации других строк.
# Эта функция выводит получившуюся строку, где каждое повторение выводится на отдельной строке.

def create_duplicate_strings(*args: str, count: int = 1) -> str:
    # соединяем переданные строки в комбинацию, повторенную count раз
    return f"{' '.join(args)}\n" * count

# 3. Функция, которая считает количество вхождений подстроки в строку без учёта регистра.

def count_substr_in_str(substr: str, string: str) -> int:
    # приводим строки и нижнему регистру и считаем количество вхождений
    return string.lower().count(substr.lower())

# 4. Функция, принимающая на вход строку и выводящая подстроку, содержащуюся между двумя индексами.
# Индексы ДОЛЖНЫ быть больше нуля и меньше длины строки минус 1.
# Тело функции ДОЛЖНО быть написано в одну строку.

def slice_string(string: str, start: int, end: int) -> str:
    return string[start:end] if 0 < start < len(string) - 1 and 0 < end < len(string) - 1 and start < end else None

# 5. Функция, принимающая на вход произвольное количество разных строк, где содержатся любые кириллические буквы,
# а также могут содержаться латинские буквы, но только такие, которые визуально неотличимы от кириллических. Регистр букв произвольный.
# Эта функция ищет слова, в которых содержатся латинские буквы.
# На выход возвращаются строки, где были обнаружены латинские символы и количество слов, в которых была обнаружена хотя бы одна латинская буква.

def get_strs_and_count_with_latin_symbols(*args: str):
    # создаём результирующий список и общее количество слов
    result_strings = list()
    result_count = 0

    # для каждой строки проверяем:
    for string in args:
        # если с помощью регулярных выражений в строке найден латинский символ, добавляем эту строку в список и увеличиваем количество на 1
        if re.search(r"[A-Za-z]", string):
            result_strings.append(string)
            result_count += 1

    # возвращаем кортеж с результатами
    return result_strings, result_count

# 6. Функция, определяющая, является ли строка палиндромом (одинаково читается с начала и с конца).
# Строка МОЖЕТ содержать как цифры, так и буквы.

def is_palindrome(value: str | int) -> bool:
    string = str(value)
    str_len = len(string)

    # проходимся по индексам строки от 0 до серединного
    for i in range(0, str_len // 2):
        # если элемент по текущему индексу не равен своему зеркальному элементу в строке, то строка уже не является палиндромом
        if string[i] != string[str_len - 1 - i]:
            return False

    # во всех других случаях возвращаем True
    return True

# 7. Функция, принимающая на вход строку, содержащую несколько слов, которые разделены одним или несколькими пробелами.
# У входной строки могут быть несколько пробелов в начале и в конце.
# Функция убирает лишние пробелы: то есть все пробелы в начале и в конце строки, а между словами оставляет только один пробел.
# Функция возвращает длину строки после удаления лишних пробелов.

# функция разделена на две, чтобы дальше можно было использовать одну из них
def remove_spaces(string: str) -> str:
    # заменяем с помощью регулярного выражения последовательность пробелов длиной от 1 на один пробел
    return re.sub(r"\s+", " ", string).strip()

def remove_spaces_and_get_len(string: str) -> int:
    # и так как в этом случае пробелы перед и после строки останутся, используем strip()
    return len(remove_spaces(string))

# но на всякий случай общий вариант:
# def remove_spaces_and_get_len(string: str) -> int:
#     # заменяем с помощью регулярного выражения последовательность пробелов длиной от 1 на один пробел
#     # и так как в этом случае пробелы перед и после строки останутся, используем strip()
#     return len(re.sub(r"\s+", " ", string).strip())

def remove_spaces_and_get_len_2(string: str) -> int:
    # разбиваем строку на элементы списка по пробелам и фильтруем по наличию длины, чтобы остались только слова
    words_filter = filter(lambda x: len(x), string.split(" "))

    # соединяем слова с помощью пробела и возвращаем длину получившейся строки
    return len(' '.join(words_filter))


# 8. Функция, принимающая на вход строку, содержащую текст из нескольких предложений.
# Функция заменяет символы окончания предложения на символ переноса строки.
# Функция возвращает получившуюся строку.

def break_sentences(string: str) -> str:
    # возвращает строку с заменёнными знаками окончания предложений с помощью регулярного выражения на спецсимвол \n,
    # обозначающий перенос строки
    # регулярное выражение ищет любое количество, большее 0, рядом стоящих знаков из [.!?] с пробелом после
    # (чтобы пробел не переносился на следующую строку в нашем случае)
    # и чтобы убрать перенос строки после замены последнего символа в начальной строке, применяем rstrip()
    return re.sub(r"[.!?]+\s*", "\n", string).rstrip()

# 9. Минимум 3 функции, содержащие произвольные алгоритмы работы со строками.
# Функции ДОЛЖНЫ решать алгоритмы, отличные от реализованных в п. 1-8

# считает количество слов в строке
def words_count(string: str) -> int:
    return len(string.split())

# дублирует все символы строки за исключением пробелов
def duplicate_all_symbols(string: str) -> str:
    # . в регулярных выражениях означает любой символ, скобки - группу, а \1 ссылается на заменяемый элемент
    duplicated_symbols = re.sub(r"(.)", r"\1\1", string)
    # возвращаем строку с удалёнными дублирующимися пробелами
    return remove_spaces(duplicated_symbols)

def reverse_string(string: str, start: int = 0, end: int = None) -> str:
    # присваиваем значение конечному индексу, если оно не передано
    # присвоение происходит в теле функции, так как в параметрах по умолчанию мы не можем дотянуться до длины переданной строки
    if end is None:
        end = len(string)
    # возвращаем итоговую строку с необходимыми манипуляциями над индексами и последовательностью элементов
    return string[:start] + string[start:end][::-1] + string[end:]
